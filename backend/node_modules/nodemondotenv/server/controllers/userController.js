require('dotenv').config();
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const { Users, Games, Orders } = require('../models/models');



const generadeJwt = (id, email, role) => {
    return jwt.sign(
        { id, email, role },
        process.env.SECRET_KEY,
        { expiresIn: '24h' }
    );
}

class UserController {
    async register(req, res) {
        const { login, name, surname, patronymic, email, password, role } = req.body;
        try {
            const existingUserByLogin = await Users.findOne({ where: { login } });
            const existingUserByEmail = await Users.findOne({ where: { email } });

            if (existingUserByLogin) {
                return res.status(400).json({ message: 'Пользователь с таким login уже зарегистрирован' });
            }

            if (existingUserByEmail) {
                return res.status(400).json({ message: 'Пользователь с таким email уже зарегистрирован' });
            }

            const hashedPassword = await bcrypt.hash(password, 5);
            const user = await Users.create({
                login, name, surname, patronymic, email, password: hashedPassword, role
            });
            const token = generadeJwt(user.id, user.login, user.role);
            return res.status(200).json({ message: 'Пользователь зарегистрирован', user, token });
        } catch (e) {
            console.log(e);
            return res.status(500).json({ message: 'Ошибка сервера' });
        }
    };

    async login(req, res) {
        const { login, password } = req.body;

        try {
            const user = await Users.findOne({ where: { login } });
            if (!user) {
                return res.status(404).json({ message: 'Пользователь с таким login не зарегистирован' });
            }

            const comparePassword = await bcrypt.compare(password, user.password);
            if (!comparePassword) {
                return res.status(400).json({ message: 'Не верный пароль' });
            }

            const token = generadeJwt(user.id, user.email, user.role);
            return res.status(200).json({ message: 'Пользователь авторизован', user, token, role: user.role });
        } catch (e) {
            return res.status(500).json({ message: 'Ошибка сервера' });
        }
    }

    async check(req, res) {
        const { id } = req.user;

        try {
            const user = await Users.findOne({ where: { id } });
            if (!user) {
                return res.status(404).json({ message: 'Пользователь не найден' });
            }

            return res.json({ id: user.id, login: user.login, email: user.email, role: user.role });
        } catch (error) {
            console.error('Ошибка при получении данных пользователя:', error);
            return res.status(500).json({ message: 'Ошибка при получении данных пользователя' });
        }
    }

    async placeOrder(req, res) {
        const { password, cartItems } = req.body;
        const { email } = req.user;

        try {
            console.log('Получен запрос на формирование заказа:', { email, password });

            const user = await Users.findOne({ where: { email } });
            if (!user) {
                console.log('Пользователь не найден:', { email });
                return res.status(404).json({ message: 'Пользователь не найден' });
            }

            const comparePassword = await bcrypt.compare(password, user.password);
            if (!comparePassword) {
                console.log('Неверный пароль:', { email, password });
                return res.status(400).json({ message: 'Неверный пароль' });
            }

            // Обновление количества товаров в базе данных
            for (const item of cartItems) {
                const game = await Games.findOne({ where: { id: item.id } });
                if (game) {
                    game.inStock -= item.quantity;
                    await game.save();
                }
            }

            // Создание нового заказа
            const order = await Orders.create({
                userId: user.id,
                status: 'Новый', // или другой статус по умолчанию
                items: cartItems
            });

            console.log('Заказ успешно сформирован:', { email });
            return res.json({ message: 'Заказ успешно сформирован', order });
        } catch (error) {
            console.error('Ошибка при формировании заказа:', error);
            return res.status(500).json({ message: 'Ошибка при формировании заказа', error });
        }
    }
}

module.exports = new UserController();
